{"meta":{"title":"MoonLeaves","subtitle":"MoonLeaves的博客","description":"致力于把有用的好玩的分享给大家，","author":"MoonLeaves","url":"http://ze520.cn","root":"/"},"pages":[{"title":"archives","date":"2020-10-01T16:00:00.000Z","updated":"2022-04-02T12:10:07.066Z","comments":true,"path":"archives/index.html","permalink":"http://ze520.cn/archives/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2022-04-02T12:07:56.000Z","updated":"2022-04-02T12:10:07.109Z","comments":false,"path":"about/index.html","permalink":"http://ze520.cn/about/index.html","excerpt":"","text":"大白菜鸡毛菜“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我QQ：3256677425 （一个敲代码的二刺猿） 座右铭：多看动漫"},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"http://ze520.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"http://ze520.cn/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"http://ze520.cn/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"http://ze520.cn/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"http://ze520.cn/tags/index.html","excerpt":"","text":""},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-07-26T07:32:21.052Z","comments":false,"path":"List/music/index.html","permalink":"http://ze520.cn/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-02T12:31:44.249Z","updated":"2022-04-02T12:31:44.249Z","comments":true,"path":"tools/index.html","permalink":"http://ze520.cn/tools/index.html","excerpt":"","text":"开发社区 代码托管 语言文档 技能训练 在线平台 高校平台 游戏编程 HOT Pythoner 文档资料 博客收藏 学习资源 组织社区 爬虫相关 HOT 学习教程 在线视频 博客论坛 学习平台 常用工具 站长工具 HOT IT工具箱 文件处理 HOT 设计素材 效率软件 HOT 服务平台 云服务商 众包平台 更多导航 关注博主 隐藏/显示侧边栏 博客首页 友情链接 评论留言 关于博主 ! function (e, t, n, a, o, i, c, r) { r = function () { i = t.createElement(n), c = t.getElementsByTagName(n)[0], i.src = o, i.charset = \"utf-8\", i.async = 1, c.parentNode.insertBefore(i, c) }, e.SeniverseWeatherWidgetObject = a, e[a] || (e[a] = function () { (e[a].q = e[a].q || []).push(arguments) }), e[a].l = +new Date, e.attachEvent ? e.attachEvent(\"onload\", r) : e .addEventListener(\"load\", r, !1) }(window, document, \"script\", \"SeniverseWeatherWidget\", \"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\" + parseInt(((new Date).getTime() / 1e8).toString(), 10)), window.SeniverseWeatherWidget(\"show\", { flavor: \"slim\", location: \"WX4FBXXFKE4F\", geolocation: !0, language: \"auto\", unit: \"c\", theme: \"auto\", token: \"a39cd5a0-4024-4cb2-85c6-0250317058db\", hover: \"enabled\", container: \"tp-weather-widget\" }) 导航内容不定期更新... 开发社区 Stack Overflow 全球最受程序员欢迎的开发社区 CSDN 全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台 博客园 代码改变世界 V2EX V2EX = way to explore 掘金 一个帮助开发者成长的社区 SegmentFault 改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功 开源中国 国内最大的开源技术社区 ITeye ITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践 51CTO 技术成就梦想 ITPUB 全球最大的学习分享平台 知乎 国内最受欢迎的知识性问答社区 简书 创作你的创作 云+社区 来自腾讯的开发者技术分享社区 云栖社区 阿里云面向开发者的开放型技术平台 极术社区 全球软硬件资源信息，只要你有问题，我们就能解答。 代码托管 Github 全球最大的面向开源及私有软件项目的托管平台 Gitlab 支持无限的公有项目和私有项目的代码托管平台 Bitbucket 同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发 SourceForge 又称 SF.net，是开源软件开发者进行开发管理的集中式场所 Coding 国内首个一站式云端软件服务平台 Gitee 国内最大的开源社区 OSChina 的代码托管平台 阿里云代码托管 阿里云旗下代码托管平台 百度效率云 百度云旗下的 Git 代码托管平台 语言文档 Zeal 脱机文档浏览器，包含196种语言API文档，支持Windows、Linux和macOS Dash 适用于Mac OS平台的软件编程文档管理工具,可以浏览API文档,以及管理代码片段工具。自带了丰富的API文档,涉及各种主流的编程语言和框架 DevDocs 在快速，有条理和可搜索的界面中结合了多个API文档，可以在移动设备上离线运行，并且可以安装在Chrome上 C/C++ C/C++ API 文档 C# C# API 文档 Java Java API 文档 .NET .NET API 文档 PHP PHP API 文档 JavaScript JavaScript API 文档 Python Python API 文档 Android Android API 文档 iOS iOS API 文档 SQL SQL API 文档 Swift Swift API 文档 Ruby Ruby API 文档 GO GO API 文档 R R API 文档 MATLAB MATLAB API 文档 Node.js Node.js API 文档 HTML HTML API 文档 CSS CSS API 文档 Redis Redis API 文档 MongoDB MongoDB API 文档 Django Django API 文档 在线平台 LeetCode 全球极客挚爱的技术成长平台 Topcoder 全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛 Codeforces 俄罗斯最大的算法比赛网站 Hihocoder 技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务 LintCode 被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站 SPOJ 波兰的算法刷题网站 NEUQ OJ 一个在线的判题平台 洛谷 创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验 牛客网 中国最大的IT题库 C语言网 在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！ 计蒜客 计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统 高校平台 POJ 北京大学程序在线评测系统 FDU OJ 复旦大学程序在线评测系统 TJ OJ 同济大学程序在线评测系统 USTC OJ 中国科学技术大学程序在线评测系统 ZOJ 浙江大学程序在线评测系统 HDU OJ 杭州电子科技大学程序在线评测系统 CSU-ACM 中南大学程序在线评测系统 HOJX 哈尔滨工业大学程序在线评测系统 HRBUST OJ 哈尔滨理工大学程序在线评测系统 PowerOJ 西南科技大学程序在线评测系统 SCU OJ 四川大学程序在线评测系统 FZU CoidngOJ 福州大学程序在线评测系统 NBUT OJ 宁波工程学院程序在线评测系统 Lutece 电子科技大学程序在线评测系统 武汉大学 ACM 协会 武汉大学 ACM 协会 ZJUT OJ 浙江工业大学程序在线评测系统 游戏编程 CheckiO 面向初学者和高级程序员的编码游戏，使用Python和JavaScript解决棘手的挑战和有趣的任务，从而提高您的编码技能 Coding Games 支持包括PHP、C、JavaScript在内的20多种编程语言。用户界面功能强大，可以定制 Codewars 一个外国的在线练习编程的网站,做题的过程类似打怪,做题升级,而且可以看到别人的解法,里面有很多巧妙的写法可以学习 CodeCombat 一个面向学生的游戏和CS学习平台。这是一个社区项目，有数百玩家自愿提供支持。支持语言包括Java、JS、Python、Lua、CoffeeScript Screeps 在游戏中学习JavaScript。世界上第一款针对程序员的MMO沙盒游戏 VIM Adventures 玩游戏的时候学VIM Cyber-Dojo 一个提供给程序员们练习写程序的地方。支持语言包括JavaScript、Java、Python、PHP、Ruby和很多其他语言 Elevator Saga 电梯编程游戏，跟随关卡解决所有挑站，使用语言为JavaScript Ruby Quiz 一个Ruby程序员提供的每周编程挑战项目 hacker.org 这项挑战由一系列本设计来强化你黑客技巧的解密、诡计、测试、烧脑环节组成。想要通关本系列，你必须学会解密、编码、渗透 Ruby Warrior 玩游戏学Ruby，通过Ruby脚本来控制一个Warrior通过每一关，每一关的代码难度都会有所增加，使玩家逐渐了解Ruby基本的函数、控制、变量、数组等语言特性的用法 文档资料 Python Selenium Python Selenium 中文翻译文档 正则表达式 Python 正则表达式官方文档 Beautiful Soup Beautiful Soup 文档 Scrapy Scrapy 爬虫框架官方文档 PySpider PySpider 爬虫框架官方文档 Matplotlib Matplotlib 2D绘图库 官方中文文档 Numpy Numpy 科学计算 官方中文文档 Pandas Pandas 结构化数据分析 官方中文文档 博客收藏 廖雪峰 廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程 学习资源 Python爬虫人工智能学习教程 Python爬虫人工智能学习教程分享 Python 中文学习大本营 Python 中文学习大本营 Python 资源大全中文版 Python 资源大全中文版 组织社区 PyChina Python 中国社区 PyCon China 中国 Python 开发者大会 蠎周刊 蠎周刊 - 汇集全球蠎事儿 爬虫相关 镀金的天空 GlidedSky 镀金的天空，在线爬虫练习题库 夜幕爬虫安全论坛 一个专注于爬虫与 PC/Web/ 移动端安全领域技术交流的社区，社区由夜幕团队 NightTeam 创办，旨在提升开发者对爬虫与软件安全防护的理解 西刺免费代理IP 每日更新免费HTTP代理，所有代理均为6675端口高匿代理，可隐藏IP 爬虫IP代理池 爬虫IP代理池 云打码 采用全球领先的秒传识别系统，50%图片零秒识别，人工平均处理时间0-3秒 超级鹰 专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大 八爪鱼采集器 一款使用简单、功能强大的网络爬虫工具，完全可视化操作，无需编写代码，内置海量模板，支持任意网络数据抓取 Python 逆向 Python 逆向相关资源 Python 爬虫集合 Python 爬虫集合 Python 入门网络爬虫之精华版 Python 入门网络爬虫之精华版 爬虫项目进阶实战 Python3 爬虫项目进阶实战、JS加解密、逆向教程、css 加密、字体加密 Python 模拟登陆一些大型网站 Python 模拟登陆一些大型网站 系统化学习 Python 爬虫 系统化学习 Python 爬虫 Python3 网络爬虫实战 Python3 网络爬虫实战 在线视频 腾讯课堂 腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师 网易云课堂 网易旗下一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作 中国大学 MOOC 中国大学MOOC(慕课)，国家精品课程在线学习平台 黑马程序员 致力于培养中级程序员，是业内以口碑闻名的IT教育培训机构 课工场 更可靠的IT就业教育平台，针对大学生量身定制人工智能、大数据、云计算、区块链、Java大数据开发等大学生IT培训课程 极客学院 极客学院作为中国专业IT职业在线教育平台,拥有海量高清IT职业课程,涵盖30+个技术领域 慕课网 慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课 尚硅谷 尚硅谷Java培训，谷粉与老学员为你推荐的Java培训、Web前端培训、前端培训、大数据培训、Python培训；0基础入学，学员就业起薪屡创新高！ 实验楼 国内领先的IT在线编程及在线实训学习平台，专业导师提供精选的实践项目，创新的技术使得学习者无需配置繁琐的本地环境，随时在线流畅使用 优达学城 Udacity是来自硅谷的前沿技术平台，为广大学子提供WEB前端开发、Python/JAVA编程、IOS/Android开发、人工智能开发等一系列在线课程及实战项目，满足学员灵活的学习需求 51CTO学院 51CTO学院IT职业在线教育平台是依托12年行业品牌、1400万IT技术用户建立的专业IT技能学习培训平台，已签约1000多位技术专家发布了12万个自学式实战视频教程 CSDN 学院 CSDN 学院作为IT在线教育平台,涵盖人工智能、考试认证、移动开发、大数据技术领域职业课程 老男孩IT教育 隶属北京一天天教育科技有限公司,是一直专注于Linux培训、Linux系统及架构师培训、Python培训、网络安全培训，大数据实战的高端培训机构 千锋教育 千锋教育 - 坚持教育初心，坚持面授品质，IT培训良心品牌 博客论坛 鱼C工作室 鱼C工作室-免费编程视频教学|Python教学|Web开发教学|全栈开发教学|C语言教学|汇编教学|Win32开发|加密与解密|Linux教学 吾爱破解 致力于软件安全与病毒分析的前沿，丰富的技术版块交相辉映，由无数热衷于软件加密解密及反病毒爱好者共同维护 廖雪峰 廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程 崔庆才 崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析 莫烦Python 专注Python、机器学习、深度学习 唐松 专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析 阮一峰 上海财经大学世界经济博士研究生，计算机科普博主，对自由软件有着坚定不移的信念 学习平台 菜鸟教程 提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识 W3school 领先的 Web 技术教程 C语言网 C语言网 - 领先实用的编程在线学习网站 前端网 前端网，最好的自学web前端网站 牛客网 牛客网 - 互联网求职神器和备考学习平台 How2J How2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容 站长工具 新浪短网址 多种后缀短网址生成 百度短网址 百度旗下专业的网址缩短服务 站长工具 - 站长之家 站长工具,SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询 阿里云 whois 查询 whois查询,域名whois,域名注册信息,whois查询工具,whois信息,域名信息 NnameBeta 国际域名搜索、域名注册、国别域名注册、域名比价 Domcomp 域名比价，Domain Name Price and Availability. 仿站工具箱 在线仿站工具箱 超级 SEO 外链工具 网站自动化宣传机器/免费的超级外链工具可批量增加外链 百度站长平台 百度搜索资源平台 - 让网站更具价值 搜狗站长平台 搜狗站长平台 - 全面掌握在搜狗搜索中的数据表现 360 站长平台 360 站长平台 - 给网站带来更多流量和展现 Google 站长平台 Google 网站站长 - 支持、学习、互动交流和 Search Console – Google Bing 网站管理员工具 Bing 网站管理员工具 百度广告联盟 百度广告联盟为您的流量增值 Google AdSense Google 广告平台 百度统计 百度统计 — 最大的中文网站分析平台 友盟+ 国内领先的第三方全域数据智能服务商 ICP/IP地址/域名信息备案管理系统 工业和信息化部ICP/IP地址/域名信息备案管理系统 全国互联网安全管理服务平台 公安备案网 - 全国互联网安全管理服务平台 IT工具箱 在线工具 - 程序员的工具箱 站长工具、代码格式化、压缩、加密、解密、下载链接转换等 在线工具 - OSCHINA.NET社区 常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等 记磊工具箱 Dns检测、CSS格式化、超级Ping、端口扫描等 孟坤工具箱 css一键美化、文本差异比较、代码高亮等 Syntax Highlight Syntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码 Text to ASCII Art Generator Text to ASCII Art Generator，字符串转成 ASCII 码图案 MDEditor 开源在线 Markdown 编辑器 临时邮箱 匿名注册不常用的网站/论坛，保护隐私免骚扰 SM.MS SM 免费图床，每个文件最大支持 5MB 路过图床 免费公共图床，支持最大10MB、批量上传 Greasy Fork 安全、实用的用户脚本大全 Hello World 大全 收集了大约481种 Hello World 程序，涵盖了目前已知的所有编程语言，另加上 67 人类语言 动画展示各种路径搜索算法 动画展示各种路径搜索算法 IT eBooks 可以下载IT电子书籍的网站（英文） GEEKTyper 在线模拟黑客工作的虚拟桌面系统，提供多种黑客工作的场景 免费计算机编程类中文书籍 免费计算机编程类中文书籍 EaseUS Partition Master 磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间 文件处理 Convertio 在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式 Office-Converter 免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式 TinyPNG PNG/JPG图片在线压缩利器 Squoosh Google开源在线压缩、调整工具，支持WebP ILoveIMG 永远免费的在线图片处理工具，可在线编辑，压缩、裁剪、转换、水印等 Smallpdf Smallpdf - A Free Solution to all your PDF Problems,PDF压缩、转换、分割、合并等 PHOTOMOSH 故障艺术在线生成，可以输出jpg、gif和视频 稿定抠图 免费在线抠图软件,图片快速换背景-抠白底图 U钙网 完全免费的LOGO在线设计制作工具 SVGOMG SVG在线压缩平台 在线图片透明圆角处理 在线图片透明圆角处理 草料二维码 国内创建二维码在线应用 Logaster 在线免费创建简单logo及名片设计 Preloaders Loading 懒加载动画在线制作 Loading 制作GIF、SVG、CSS加载动画图标 waifu2x 图片智能无损放大2倍，适合动漫、插画等 智图 腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台 音乐免费下载 全网音乐免费下载工具 OK资源采集 OK资源采集-最新影视资源大全 网易见外工作台 针对视频、图片、文档、音频都可以进行翻译转写操作，每天两小时免费使用 HiPDF 一站式解决所有PDF相关的问题 视频鱼 在线下载各大网站视频的网站 ScreenToGif 开源、轻量级却非常强大的录屏软件，快速将屏幕录制成高清GIF 设计素材 Iconfont 阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能 Font Awesome 一个基于CSS 和 LESS 的字体和图标工具包 Flaticon 海量扁平化免费的图标库 icons8 独特系统平台风格和web图标库，下载免费图标，音乐 千图网 海量原创设计模板免费下载 昵图网 国内海量平面免费素材下载 千库网 免费 png 图片背景素材下载 Pexels 才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频 必应壁纸 必应每日高清壁纸 Piqsels 精美的免版税图库 私藏字体 优质字体免费下载站 第一 PPT 网 免费 PPT 模板下载 吾道幻灯片 全新的office生产力工具，支持演示文稿、PPT模板、协同办公，可以帮助用户轻松创建具有视觉吸引力的幻灯片 Mixkit 免费、高质量、可商用的视频素材分享网站 The Stocks 对各大图片网站进行整合，免费优质图片下载 极简壁纸 高质量精品壁纸网站 NASA Image and Video Library 美国国家航天局的官方库，从此太空类的素材再也不是问题 Unsplash 质量超高的免费图片素材库，无需注册，直接下载 WordArt 文字云工具 效率软件 分流抢票 全程自动抢票,自动抢候补,自动识别验证码,多线程秒单、稳定捡漏,支持多天、多车次、多席别、多乘客等功能 PanDownload 百度网盘下载神器 Quicker 为常用操作建立捷径，PC 快捷动作面板，让效率触手可及! 万彩办公大师 免费、轻松处理文档/音视频/图片的工具 LICEcap 简洁易用的动画屏幕录制软件，它可将屏幕录像的内容直接保存为高质量（每帧颜色数量可超过256）GIF动态图片格式 Snipaste 简单但强大的截图工具，支持截图 + 贴图 FSCapture 一个强大的，轻量级的，功能齐全的屏幕捕获工具 Everything 速度最快的的文件搜索工具 DeskPins 顶置任意窗口 TrafficMonitor 一个用于显示当前网速、CPU及内存利用率的桌面悬浮窗软件 PicGo 由 electronic-vue 构建的简单而精美的图片上传工具 PowerToys 微软为 Windows 系统推出的一系列免费实用小工具合集 Dism++ 一款根据微软底层的架构结构设计的一个系统维护工具，全球第一款基于 CBS 的 Dism GUI 实现 ColorPix 屏幕取色小工具 CCleaner 一款免费的系统优化和隐私保护工具 GifCam 集录制与剪辑为一体的屏幕 GIF 动画制作工具，录制后的动画可以逐帧编辑 EV录屏 一款免费并且不添加水印的录屏工具 Fliqlo 一款极简主义的时钟屏保软件 Fences 栅栏管理桌面，使桌面更加整洁有条理 Q-dir 多窗口文件整理工具 WGestures 鼠标手势工具 XMind 一个全功能的思维导图和头脑风暴软件 速盘 免登录，自动查询提取码，极速的度盘下载工具 f.lux 国外开源的护眼软件，通过根据时间调节屏幕颜色，减少蓝光对视力的影响 云服务商 阿里云 阿里云 - 为了无法计算的价值 腾讯云 腾讯云 - 产业智变 云启未来 百度云 百度云 - 计算无限可能 华为云 华为云 - +智能，见未来 京东云 京东云 - 遇见无限可能 西部数码 西部数码 - 云服务器、虚拟主机、域名注册17年知名云计算服务提供商！ 景安云 景安云 - 专业的数据中心服务商 七牛云 七牛云 - 国内领先的企业级云服务商 又拍云 又拍云 - 加速在线业务-CDN-云存储 美橙互联 美橙互联 - 域名注册、企业建站、云服务器、企业网络推广整体解决方案服务商！ UCloud UCloud - 中立 安全 可信赖的云计算服务商 AWS AWS 云服务 - 专业的大数据和云计算服务以及云解决方案提供商 Microsoft Azure Azure. Invent with purpose. GoDaddy GoDaddy - 提供域名注册和互联网主机服务的美国公司 Cloudflare Cloudflare - 网络性能和安全公司 jsDelivr jsDelivr - A free, fast, and reliable Open Source CDN for npm and GitHub 众包平台 猿急送 专注于 IT 众包领域，职位内容大多集中于 UI 设计、产品设计、程序开发、产品运营等需求 开源众包 开源中国旗下外包网站，项目大多是团队的整包项目，适合多人组团接单 外包大师 PMCAFF旗下的一个众包开发平台，目前以技术开发为主，以众包开发和自有开发相结合形式运营 人人开发 集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台 快码 提供智能硬件、各种智能共享项目解决方案，为互联网创业者提供APP、小程序、公众号开发。 我爱方案网 专注于硬件类外包，电子方案开发供应链众包平台，软件外包，方案，硬件开发方案，硬件设计开发 英选 提供可信赖的定制开发外包服务，包括企业品牌官网、电商系统及创新定制产品开发 智筹 为企业&amp;创业者提供互联网高级人才直租服务。按次直租，解决临时、突发问题；按月直租，建立长期兼职合作；按任务直租，解决有明确预算的外包任务 开发邦 互联网软件定制开发与软件外包开发服务，十年互联网软件定制开发经验 码市 Coding 推出的互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作 自由职客 自由职客是权威的IT互联网行业灵活用工交易平台，外包，众包，兼职，招聘，erp，sap 解放号 解放号众包平台提供软件开发外包、人力驻场服务等软件项目外包服务。解放号的软件项目交付全流程可视化监控与全生命周期管理能力 程序员客栈 领先的程序员自由工作平台，38万+优秀开发者，您的专属云端开发团队，BAT级别的开发者，标准化的服务和交付 码易 智网易联旗下IT软件服务平台，集软件商城、企业应用、电商软件、crm软件、商务服务平台于一体的一站式软件外包开发服务平台 电鸭社区 电鸭社区旨在推动自由工作方式在国内渐进式发展，区别于传统方式的工作职位，倡导「只工作，不上班」的工作心态 Sxsoft 中国最早的外包服务平台，18年口碑服务，20万程序员、100+专业软件开发公司，专注解决各类软件开发需求 实现网 为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求 智城外包网 零佣金开发资源平台，认证担保，全程无忧，专业的软件外包网和项目外包、项目开发、人力外派、短期招聘、人力资源交易平台 更多导航 创造狮导航 创造狮，一个创意工作者的导航，专注分享正版优质设计、前端、产品、运营的书签导航，设计教程、设计规范、颜色搭配、灵感创意、前端框架、开发者工具、互联网新品推荐、运营数据分析、自媒体和工具利器好用的分类导航大全 大数据导航 大数据导航，以大数据产业为主，大数据工具为辅，给用户提供一个更加快速找到大数据相关的工具平台 优设导航 优设网站导航为设计师提供ps教程、UI设计、素材下载、高清图库、配色方案、用户体验、网页设计等全方位设计师网站导航指引 牛导航 实用工具导航 聚BT 聚BT - 聚合最优质的BT、磁力资源 ShareHub ShareHub - 资源和工具的集合 狼牌工作网址导航 工具，资源，方法，All IN ONE的办公工作网址导航 COPYRIGHT 2019 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY xianqi $(document).ready(function () { return $(document).on(\"click\", \".has-sub\", function () { var e = $(this); $(this).hasClass(\"expanded\") ? $(\".has-sub ul\").each(function (s, i) { var t = $(this); e.find(\"ul\")[0] != i && setTimeout(function () { t.attr(\"style\", \"\") }, 300) }) : setTimeout(function () { e.find(\"ul\").attr(\"style\", \"\") }, 300) }), $(\".user-info-menu .hidden-sm\").click(function () { $(\".sidebar-menu\").hasClass(\"collapsed\") ? $(\".has-sub.expanded > ul\").attr(\"style\", \"\") : $(\".has-sub.expanded > ul\").show() }), $(\"#main-menu li ul li\").click(function () { $(this).siblings(\"li\").removeClass(\"active\"), $(this).addClass(\"active\") }), $(\"a.smooth\").click(function (s) { s.preventDefault(), public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass( \"mobile-is-visible\"), ps_destroy(), $(\"html, body\").animate({ scrollTop: $($(this).attr(\"href\")).offset().top - 30 }, { duration: 500, easing: \"swing\" }) }), !1 }); var href = \"\", pos = 0; $(\"a.smooth\").click(function (s) { $(\"#main-menu li\").each(function () { $(this).removeClass(\"active\") }), $(this).parent(\"li\").addClass(\"active\"), s.preventDefault(), href = $(this).attr(\"href\"), pos = $(href).position().top - 30 })"}],"posts":[{"title":"java面试系列-第2篇【集合详解】","slug":"java面试系列-第2篇【集合详解】","date":"2022-04-12T01:14:09.000Z","updated":"2022-04-12T02:29:09.525Z","comments":true,"path":"posts/701901c7.html","link":"","permalink":"http://ze520.cn/posts/701901c7.html","excerpt":"","text":"java面试系列-第2篇【集合详解】集合是java基础中很重要的一块大骨头，我们先看一下整体结构。 2.1 List2.1.1 ArrayList(数组)​ ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 2.1.2 Vector(数组实现、线程同步)​ Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 2.1.3 LinkList(链表)​ LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 2.2 Set​ Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法 2.2.1 HashSet(Hash表)​ 哈希表里存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。 ​ 哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。 如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。 HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。 2.2.2 TreeSet(二叉树) TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数 2.2.3 LinkHashSet(HashSet+LinkedHashMap)对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。 ​ LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 2.3 Map2.3.1 HashMap(数组+链表+红黑树)​ HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导 致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者可以使用ConcurrentHashMap。我们用下面这张图来介绍HashMap 的结构。 2.3.1.1HashMap–java7实现 ​ 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 loadFactor：负载因子，默认为 0.75。 threshold：扩容的阈值，等于 capacity * loadFactor 2.3.1.2HashMap–java8实现Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树组成 ​ 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 2.3.2 ConcurrentHashMap2.3.2.1 ConcurrentHashMap–java7实现​ ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。Segment 继承 ReentrantLock 加锁 ​ 简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Seggment 是线程安全的，也就实现了全局的线程安全。 2.3.2.2 ConcurrentHashMap并行度（默认16）concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支 持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 2.3.2.3 ConcurrentHashMap–java8实现（引入了红黑树）Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。","categories":[{"name":"java面试","slug":"java面试","permalink":"http://ze520.cn/categories/java%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"jvm系列-第2篇【类加载子系统】","slug":"jvm系列-第2篇【类加载子系统】","date":"2022-04-10T02:59:27.000Z","updated":"2022-04-11T08:02:25.584Z","comments":true,"path":"posts/9bbea6db.html","link":"","permalink":"http://ze520.cn/posts/9bbea6db.html","excerpt":"","text":"2.类加载子系统2.1类加载系统的位置好的~我们接下来就要学习类加载子系统的知识了，冲冲冲！！ 首先我们回顾看一下类加载子系统在jvm中的位置。 2.2类加载器的作用 类加载子系统负责从文件系统或者网络中加载Clas文件,class文件在文件开头有特定的文件标识（后面会讲到，这个被称为“魔术”）。 classLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。 加载的类信息存放于一块称为方法区的内存空间。（方法区也是后面一个重点，我们后面会慢慢介绍） 2.3类加载器系统的执行流程 类加载系统的加载过程 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.class对象作为方法区这个类的各种数据的访问入口 类加载系统的链接过程 类加载系统的初始化过程 2.4类加载器的分类JVM有两种类型的加载器：引导类加载器和自定义类加载器 Bootstrap Class Loader 是引导类加载器，其余的都是自定义类加载器 2.4.1启动类加载器 2.4.2扩展类加载器 2.4.3应用程序类加载器 2.4.4自定义类加载器我们平时开发中，类加载几乎都是上面3种类加载器配合使用的，那我们为什么还需要使用自定义类加载器呢？ 防止加载类 修改类加载的方式 扩展加载源 防止源码泄露 问：关于如何编写自定义类加载器呢？ 答：我们可以直接继承URLClassLoader类 【注：本教程旨在互相学习，有借鉴搬移其他平台（比如尚硅谷）的成分，不为盈利（bilbil尚硅谷确实很好）】","categories":[{"name":"jvm","slug":"jvm","permalink":"http://ze520.cn/categories/jvm/"}],"tags":[]},{"title":"在idea中以Typora打开.md文件的方法","slug":"在idea中以Typora打开.md文件的方法","date":"2022-04-07T05:22:10.000Z","updated":"2022-04-10T08:31:39.457Z","comments":true,"path":"posts/2e40f549.html","link":"","permalink":"http://ze520.cn/posts/2e40f549.html","excerpt":"","text":"在写博客的时候使用idea自带的.md书写模式感觉好怪，所以我寻找了一下如何在idea中以Typora打开以.md结尾的文件。 这样idea就会以系统默认的方式打开.md文件","categories":[],"tags":[{"name":"tips","slug":"tips","permalink":"http://ze520.cn/tags/tips/"}]},{"title":"spring系列-第1篇【手写部分spring源码】","slug":"spring系列-第1篇【手写部分spring源码】","date":"2022-04-07T04:07:25.000Z","updated":"2022-04-10T09:19:09.012Z","comments":true,"path":"posts/d882f8af.html","link":"","permalink":"http://ze520.cn/posts/d882f8af.html","excerpt":"","text":"package com.moon.spring; /** * @author MoonLeaves * @create 2022-04-05 13:37 * @describe:这是spring容器，作为一个容器，是用来存放创建的对象仓库 */ import java.beans.Introspector; import java.io.File; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.net.URL; import java.util.ArrayList; import java.util.concurrent.ConcurrentHashMap; /** * ComponentScan,Component方面联系: * 作为一个仓库，他是利用component去判定哪一个是要被创建的对象，所以他必须和component有关系，即找到扫描路径 */ public class MoonApplicationContext { public static String CONSTANT_SCOPE_NAME_SINGLETON = \"singleton\"; public static String CONSTANT_SCOPE_NAME_PROPERTY = \"property\"; private Class configClass; private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(); //单例池 private ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(); //判断出一个Component之后就判断这个clazz是否有BeanPostProcessor接口 private ArrayList&lt;BeanPostProcessor&gt; beanPostProcessorList = new ArrayList&lt;&gt;(); /** * 这个构造方法就是接受到一个配置类，然后判断是否是ComponentScan注解 * 如果有ComponentScan注解: * 1.就根据ComponentScan的value找到要扫描的包com.moon.service【这一步运用了classLoader.getResource得到；文件在项目中的绝对路径】 * 2.然后拿到包内的所有文件，筛选出class结尾的文件 * 3.遍历：然后去所有的class文件中去遍历所有标注了Component注解的文件 * 4.有Component注解的类就是我们想要的鉴定的类 * 5.我们用一个包装bean对象( BeanDefinition )去封装原始类， * 6.需要封装的其实就是这个类的Class属性和scope.value * 7.遍历之后：所以要把他存起来，ConcurrentHashMap&lt;String, BeanDefinition&gt;，存放的是bean名字和bean封装对象(Class,scope) * &lt;p&gt; * 8.按说遍历之后就已经结束了，但是spring绝对在容器创建成功之后，直接把单例模式的bean创建一下所以 * 9.创建单例bean对象,创建bean对象用的是一个private类型的createBean() * 10.为了创建单例对象，我们先设计一个单例池ConcurrentHashMap&lt;String, Object&gt; * 11.每次创建成功单例bean对象，就把这个对象放到单例池中. * 12.我们对外开启的getBean()方法就从这个池子里拿取 * * @param configClass */ /** * 关于依赖注入： * &lt;p&gt; * 前面我们完成了容器的创建，找到了bean,然后创建bean,但是我们创建还没有完成，因为没有解决依赖注入的方法。 * 依赖注入就是要求在创建bean对象之后就把值给赋了，所以 * 在Object instance = clazz.getConstructor().newInstance();执行之后就先要遍历他的属性，然后看看是否有Autowired注解，如果有 * 就证明这个属性也是通过spring去创建的，所以我们调用 f.set(instance, getBean(f.getName()));去创建对象。【注意这里有个A.B问题】 * &lt;p&gt; * &lt;p&gt; * &lt;p&gt; * 关于回调机制和初始化机制： * &lt;p&gt; * 因为我们借助的是两个接口（BeanNameAware，InitializingBean）去判断他是否有这个操作，在createdBean内，我们就要判断是否有这个注解，然后去操作 * &lt;p&gt; * &lt;p&gt; * &lt;p&gt; * 关于AOP机制： * &lt;p&gt; * 我们也是需要一个接口BeanPostProcessor，在判断出他是一个component之后，就判断他是否有BeanPostProcessor接口，如果有就添加到一个池子里beanPostProcessorList，方便以后使用 * 在我们进行完回调和初始化机制之后，我们就可以执行BeanPostProcessor的前置方法了 */ public MoonApplicationContext(Class configClass) { this.configClass = configClass; //判断是否有ComponentScan注解 if (configClass.isAnnotationPresent(ComponentScan.class)) { //如果有就获取到这个ComponentScan注解类对象 ComponentScan ComponentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class); //所以这就是ComponentScan的扫描路径，其实一个包名com.moon.service String path = ComponentScanAnnotation.value(); //com.moon.service---&gt;com/moon/service path = path.replace(\".\", \"/\"); //tips:我们根据classpath去获取真正的路径名 //获取容器的类加载器 ClassLoader classLoader = MoonApplicationContext.class.getClassLoader(); //根据类加载器能得到资源 URL resource = classLoader.getResource(path); //此时获取到的file路径就是我们想要的 File file = new File(resource.getFile()); //D:\\Study\\Code\\Study\\Spring\\SpringSourceCode\\SpringSourceCode_01\\target\\classes\\com\\moon\\service // System.out.println(file); if (file.isDirectory()) { //获取到文件夹内所有的文件 File[] files = file.listFiles(); for (File f : files) { String filename = f.getAbsolutePath(); //获取到所有的文件名 D:\\Study\\Code\\Study\\Spring\\SpringSourceCode\\SpringSourceCode_01\\target\\classes\\com\\moon\\service\\UserService.class // System.out.println(filename); if (filename.endsWith(\".class\")) { // com\\moon\\service\\UserService String className = filename.substring(filename.indexOf(\"com\"), filename.indexOf(\".class\")); // com.moon.service.UserService className = className.replace(\"\\\\\", \".\"); // System.out.println(className); //使用类加载器，传入类的全限定名加载类 try { //使用类加载器加载类 Class&lt;?&gt; clazz = classLoader.loadClass(className); //如果有Component注解,就证明这个是bean对象 if (clazz.isAnnotationPresent(Component.class)) { //判断这个类是否是实现了BeanPostProcessor接口 if (BeanPostProcessor.class.isAssignableFrom(clazz)) { BeanPostProcessor instance = (BeanPostProcessor) clazz.newInstance(); beanPostProcessorList.add(instance); } Component component = clazz.getAnnotation(Component.class); //获取bean的名字 String beanName = component.value(); //spring要求生成的bean名字首字母要小写 if (beanName.equals(\"\")) { beanName = Introspector.decapitalize(clazz.getSimpleName()); } //这个是包装bean类型 BeanDefinition beanDefinition = new BeanDefinition(); //设置包装bean类型的类 beanDefinition.setType(clazz); //然后判断是否这个类是否有scope注解 if (clazz.isAnnotationPresent(Scope.class)) { Scope scopeAnnotation = clazz.getAnnotation(Scope.class); //这个类的scope值 beanDefinition.setScope(scopeAnnotation.value()); } else { beanDefinition.setScope(CONSTANT_SCOPE_NAME_SINGLETON); } //向集合中中添加bean beanDefinitionMap.put(beanName, beanDefinition); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } } } } for (String beanName : beanDefinitionMap.keySet()) { BeanDefinition beanDefinition = beanDefinitionMap.get(beanName); if (beanDefinition.getScope().equals(CONSTANT_SCOPE_NAME_SINGLETON)) { //创建单例bean Object bean = createBean(beanName, beanDefinition); singletonObjects.put(beanName, bean); } } } public Object getBean(String beanName) { /** * 1.根据beanName得到类在哪里 * 2.判断是否是单例bean */ BeanDefinition beanDefinition = beanDefinitionMap.get(beanName); if (beanDefinition == null) { throw new NullPointerException(); } else { String scope = beanDefinition.getScope(); //如果是单例模式 if (scope.equals(CONSTANT_SCOPE_NAME_SINGLETON)) { //我们从单例池中获取，单例池内的数据是在容器创建完成后就添加的 Object bean = singletonObjects.get(beanName); //有一种情形，就是A.B 如果要创建A,而A引用了B，但是A先被扫描到了，B还有创建，所以就创建B if (bean == null) { Object o = createBean(beanName, beanDefinition); singletonObjects.put(beanName, o); } return bean; } //多例模式 else { return createBean(beanName, beanDefinition); } } } private Object createBean(String beanName, BeanDefinition beanDefinition) { //当前bean对应的类 Class clazz = beanDefinition.getType(); //使用无参构造方法生成一个bean try { Object instance = clazz.getConstructor().newInstance(); //给一个bean依赖注入，首先要遍历一个bean的属性 for (Field f : clazz.getDeclaredFields()) { if (f.isAnnotationPresent(Autowired.class)) { f.setAccessible(true); //f.getName()找的就是OrderService orderService中的 orderService //A.B 此时就先去创建B f.set(instance, getBean(f.getName())); } } //如果当前类实现了BeanNameAware接口 if (instance instanceof BeanNameAware) { //回调机制，直接自己干事 ((BeanNameAware) instance).setBeanName(beanName); } for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) { instance = beanPostProcessor.postProcessBeforeInitialization(beanName, instance); } if (instance instanceof InitializingBean) { //初始化机制，只用于调用，但是具体做了什么事情，用户才知道，调用的是用户的方法 ((InitializingBean) instance).afterPropertiesSet(); } for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) { instance = beanPostProcessor.postProcessAfterInitialization(beanName, instance); } return instance; } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } return null; } }","categories":[{"name":"spring","slug":"spring","permalink":"http://ze520.cn/categories/spring/"}],"tags":[]},{"title":"jvm系列-第1篇【jvm基本结构】","slug":"jvm系列-第1篇【jvm基本结构】","date":"2022-04-07T04:06:52.000Z","updated":"2022-04-11T07:59:51.890Z","comments":true,"path":"posts/15bc6d90.html","link":"","permalink":"http://ze520.cn/posts/15bc6d90.html","excerpt":"","text":"jvm系列-第1篇【jvm基本结构】1.jvm是什么？JVM是java虚拟机（Java Virtual Machine）的英文简称。 ​ 虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 简单来说JVM是用来解析和运行Java程序的。 大家都知道Java是跨平台的语言，这都要归功于java虚拟机，即jvm的作用。为了让大家更好理解jvm的跨平台性，这里贴一张图。 Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码==（字节码）==，就可以在多种平台上不加修改地运行。最终实现一次编译，到处执行。 那么jvm在那里呢？ ​ 用户使用编译器（javac指令）编译出字节码文件【tips:1】。然后只要你的电脑里安装了jre【tips:2】，就可以运行这个字节码文件了。 tips1:【idea这种是编辑器，他可以使用快捷的使用javac编译出字节码文件】 tips2:【我们安装的jdk（开发工具包）已经包括了jre(运行环境)】 【JRE包括JVM,JDK包括JRE,IDEA使用JDK】 好了，我们要学习的重点只是就是os上，jre下的JVM，鼎鼎大名的==JVM虚拟机==！！ 2.jvm包括什么？jvm其实很复杂，这里先给大家展示一下他的简略结构图 看图我们知道，jvm有以下几个部分： 类加载子系统 运行时数据区【方法区，堆，java栈，本地方法栈，程序计数器】 执行引擎 本地方法接口 本地方法库 ​ 前面说过，我们是通过编译器编译出==字节码文件==，然后给jvm的，所以我们看这个图可以发现，jvm的初始入口就是从字节码文件开始的。 我们将这个图稍微细化一些。 同学们，不要慌。我们接下来将会对这里面的结构进行拆块的剖析。 【注：本教程旨在互相学习，有借鉴搬移其他平台（比如尚硅谷）的成分，不为盈利（bilbil尚硅谷确实很好）】","categories":[{"name":"jvm","slug":"jvm","permalink":"http://ze520.cn/categories/jvm/"}],"tags":[]},{"title":"java面试系列-第1篇【java基础】","slug":"java面试系列-第1篇【java基础】","date":"2022-04-07T04:06:04.000Z","updated":"2022-04-12T02:29:15.451Z","comments":true,"path":"posts/96ab36bf.html","link":"","permalink":"http://ze520.cn/posts/96ab36bf.html","excerpt":"","text":"第一篇 java基础1.面向对象和面向过程的区别面向过程：优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗 资源;比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是 最重要的因素。 缺点： 没有面向对象易维护、易复用、易扩展 面向对象优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点： 性能比面向过程低 2.什么是字节码文件​ 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文 件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计算机上运行 3.java面向对象编程的三大特征？封装概念：即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。 优点： 把对象的私有数据和公共数据分离开，保护了私有数据，减少了可能的模块间干扰，达到降低程序复杂性、提高可控性的目的。 清楚的体现了系统之间的松散耦合关系,提高系统的独立性； 提高了程序的可复用性和可维护性，降低了程序员保持数据与操作内容的负担。 继承概念：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 优点： 简化代码，提高复用性； 增加可维护性； 继承注意事项： 子类不继承其父类的构造方法。 当使用无参数的super()时，父类的无参数构造方法就会被调用； 当使用带有参数的super()方法时，父类的有参数构造方法就会被调用。 子类继承其父类的所有public和protected成员，但不能继承其父类的private成员。 重写父类中的方法：当一个子类中一个实例方法具有与其父类中的一个实例方法相同的签名（指名称、参数个数和类型）和返回值时，称子类中的方法“重写”了父类的方法。调用重写方法时，调用的为子类重写的方法。 隐藏父类中的方法：如果一个子类定义了一个静态类方法，而这个类方法与其父类的一个类方法具有相同的签名（指名称、参数格式和类型）和返回值，则称在子类中的这个类方法“隐藏”了父类中的该类方法。调用隐藏方法时，取决于对象是父类对象的调用还是子类对象的调用 可以在子类中通过使用关键字super()来调用父类中被重写的方法和访问父类中被隐藏的字段。 多态概念：统一行为具有多个不同表现形式或形态能力 优点： 消除类型之间的耦合关系 可扩充性 接口性 灵活性 简化性 可替换性 多态的实现方式： 方式1：重载和重写 重载：在一个类中，同一方法名称，不同的参数及个数，可以完成不同的功能 重写：同一个方法名称，子类继承父类的方法，根据操作的子类不同，所完成的功能也不同。 方式2：抽象类和抽象方法 抽象方法:一个没有方法体的方法称为抽象方法。abstract 特点: 抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类 抽象类不可以是实例化 抽象类的子类，可以是抽象类，也可以是具体类。如果子类为具体类，需要重写抽象类中所有抽象方法 方式3：接口 定义:是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。 接口无法被实例化，但是可以被实现.一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。 4.hashCode 与equals面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals 时必须重写 hashCode 方法？ hashCode()介绍​ hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整 数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函 数 ​ 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode我们以”HashSet如何检查重复”为例子来说明为什么要有hashCode： ​ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度 hashCode（）与equals（）的相关规定 如果两个对象相等，则 hashcode 一定也是相同的 两个对象相等,对两个对象分别调用 equals 方法都返回 true 两个对象有相同的 hashcode 值，它们也不一定是相等的 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）","categories":[{"name":"java面试","slug":"java面试","permalink":"http://ze520.cn/categories/java%E9%9D%A2%E8%AF%95/"}],"tags":[]}],"categories":[{"name":"java面试","slug":"java面试","permalink":"http://ze520.cn/categories/java%E9%9D%A2%E8%AF%95/"},{"name":"jvm","slug":"jvm","permalink":"http://ze520.cn/categories/jvm/"},{"name":"spring","slug":"spring","permalink":"http://ze520.cn/categories/spring/"}],"tags":[{"name":"tips","slug":"tips","permalink":"http://ze520.cn/tags/tips/"}]}