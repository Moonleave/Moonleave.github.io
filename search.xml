<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java面试系列-第2篇【集合详解】</title>
      <link href="/posts/701901c7.html"/>
      <url>/posts/701901c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="java面试系列-第2篇【集合详解】"><a href="#java面试系列-第2篇【集合详解】" class="headerlink" title="java面试系列-第2篇【集合详解】"></a>java面试系列-第2篇【集合详解】</h1><p>集合是java基础中很重要的一块大骨头，我们先看一下整体结构。</p><p><img src="../images/java_test/java_test-2-%E9%9B%86%E5%90%88%E6%95%B4%E4%BD%93.jpg"></p><h2 id="2-1-List"><a href="#2-1-List" class="headerlink" title="2.1 List"></a>2.1 List</h2><h3 id="2-1-1-ArrayList-数组"><a href="#2-1-1-ArrayList-数组" class="headerlink" title="2.1.1 ArrayList(数组)"></a>2.1.1 ArrayList(数组)</h3><p>​    ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p><h3 id="2-1-2-Vector-数组实现、线程同步"><a href="#2-1-2-Vector-数组实现、线程同步" class="headerlink" title="2.1.2 Vector(数组实现、线程同步)"></a>2.1.2 Vector(数组实现、线程同步)</h3><p>​    Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</p><h3 id="2-1-3-LinkList-链表"><a href="#2-1-3-LinkList-链表" class="headerlink" title="2.1.3 LinkList(链表)"></a>2.1.3 LinkList(链表)</h3><p>​    LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p><h2 id="2-2-Set"><a href="#2-2-Set" class="headerlink" title="2.2 Set"></a>2.2 Set</h2><p>​    Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法</p><h3 id="2-2-1-HashSet-Hash表"><a href="#2-2-1-HashSet-Hash表" class="headerlink" title="2.2.1 HashSet(Hash表)"></a>2.2.1 HashSet(Hash表)</h3><p>​    哈希表里存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的<code>hashcode </code>方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</p><p>​    哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。</p><p><img src="../images/java_test/java_test-2-HashCodeAndEquals.jpg"></p><blockquote><p>如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。</p></blockquote><p>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</p><h3 id="2-2-2-TreeSet-二叉树"><a href="#2-2-2-TreeSet-二叉树" class="headerlink" title="2.2.2 TreeSet(二叉树)"></a>2.2.2 TreeSet(二叉树)</h3><ol><li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </li><li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</li><li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li><li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数</li></ol><h3 id="2-2-3-LinkHashSet-HashSet-LinkedHashMap"><a href="#2-2-3-LinkHashSet-HashSet-LinkedHashMap" class="headerlink" title="2.2.3 LinkHashSet(HashSet+LinkedHashMap)"></a>2.2.3 LinkHashSet(HashSet+LinkedHashMap)</h3><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。 </p><p>​    LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p><h2 id="2-3-Map"><a href="#2-3-Map" class="headerlink" title="2.3 Map"></a>2.3 Map</h2><h3 id="2-3-1-HashMap-数组-链表-红黑树"><a href="#2-3-1-HashMap-数组-链表-红黑树" class="headerlink" title="2.3.1 HashMap(数组+链表+红黑树)"></a>2.3.1 HashMap(数组+链表+红黑树)</h3><p>​    HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的<code>键</code>为 null，允许多条记录的<code>值</code>为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导 致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者可以使用ConcurrentHashMap。我们用下面这张图来介绍HashMap 的结构。 </p><h4 id="2-3-1-1HashMap–java7实现"><a href="#2-3-1-1HashMap–java7实现" class="headerlink" title="2.3.1.1HashMap–java7实现"></a>2.3.1.1HashMap–java7实现</h4><p><img src="../images/java_test/java_test-2-java7%E7%9A%84HashMap.jpg"></p><p>​    大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 </p><ol><li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li><li>loadFactor：负载因子，默认为 0.75。</li><li>threshold：扩容的阈值，等于 capacity * loadFactor</li></ol><h4 id="2-3-1-2HashMap–java8实现"><a href="#2-3-1-2HashMap–java8实现" class="headerlink" title="2.3.1.2HashMap–java8实现"></a>2.3.1.2HashMap–java8实现</h4><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树组成</p><p>​    根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 </p><p><img src="../images/java_test/java_test-2-java8%E7%9A%84HashMap.jpg"></p><h3 id="2-3-2-ConcurrentHashMap"><a href="#2-3-2-ConcurrentHashMap" class="headerlink" title="2.3.2 ConcurrentHashMap"></a>2.3.2 ConcurrentHashMap</h3><h4 id="2-3-2-1-ConcurrentHashMap–java7实现"><a href="#2-3-2-1-ConcurrentHashMap–java7实现" class="headerlink" title="2.3.2.1 ConcurrentHashMap–java7实现"></a>2.3.2.1 ConcurrentHashMap–java7实现</h4><p>​    ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。<strong>Segment</strong> <strong>继承</strong> <strong>ReentrantLock</strong> <strong>加锁</strong></p><p>​    简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Seggment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="../images/java_test/java_test-2-java7%E7%9A%84ConcurrentHashMap.jpg"></p><h4 id="2-3-2-2-ConcurrentHashMap并行度（默认16）"><a href="#2-3-2-2-ConcurrentHashMap并行度（默认16）" class="headerlink" title="2.3.2.2 ConcurrentHashMap并行度（默认16）"></a>2.3.2.2 ConcurrentHashMap并行度（默认16）</h4><p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支 持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h4 id="2-3-2-3-ConcurrentHashMap–java8实现（引入了红黑树）"><a href="#2-3-2-3-ConcurrentHashMap–java8实现（引入了红黑树）" class="headerlink" title="2.3.2.3 ConcurrentHashMap–java8实现（引入了红黑树）"></a>2.3.2.3 ConcurrentHashMap–java8实现（引入了红黑树）</h4><p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。</p><p><img src="../images/java_test/java_test-2-java8%E7%9A%84ConcurrentHashMap.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> java面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm系列-第2篇【类加载子系统】</title>
      <link href="/posts/9bbea6db.html"/>
      <url>/posts/9bbea6db.html</url>
      
        <content type="html"><![CDATA[<h1 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2.类加载子系统"></a>2.类加载子系统</h1><h2 id="2-1类加载系统的位置"><a href="#2-1类加载系统的位置" class="headerlink" title="2.1类加载系统的位置"></a>2.1类加载系统的位置</h2><p>好的~我们接下来就要学习类加载子系统的知识了，冲冲冲！！</p><p>首先我们回顾看一下<code>类加载子系统</code>在jvm中的位置。</p><p><img src="../images/jvm/jvm-1-jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></p><h2 id="2-2类加载器的作用"><a href="#2-2类加载器的作用" class="headerlink" title="2.2类加载器的作用"></a>2.2类加载器的作用</h2><ul><li>类加载子系统负责从文件系统或者网络中<code>加载Clas文件</code>,class文件在文件开头有特定的文件标识（后面会讲到，这个被称为“魔术”）。</li><li>classLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。</li><li>加载的类信息存放于一块称为<code>方法区</code>的内存空间。（方法区也是后面一个重点，我们后面会慢慢介绍）</li></ul><p><img src="../images/jvm/jvm-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%A7%92%E8%89%B2.jpg"></p><h2 id="2-3类加载器系统的执行流程"><a href="#2-3类加载器系统的执行流程" class="headerlink" title="2.3类加载器系统的执行流程"></a>2.3类加载器系统的执行流程</h2><p><img src="../images/jvm/jvm-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg"></p><ol><li><p>类加载系统的<code>加载</code>过程</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.class对象</code>作为方法区这个类的各种数据的访问入口</li></ol></li><li><p>类加载系统的<code>链接</code>过程</p><p><img src="../images/jvm/jvm-2-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg"></p></li><li><p>类加载系统的初始化过程</p><p><img src="../images/jvm/jvm-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg"></p></li></ol><h2 id="2-4类加载器的分类"><a href="#2-4类加载器的分类" class="headerlink" title="2.4类加载器的分类"></a>2.4类加载器的分类</h2><p>JVM有两种类型的加载器：引导类加载器和自定义类加载器</p><p>Bootstrap Class Loader 是引导类加载器，其余的都是自定义类加载器</p><h3 id="2-4-1启动类加载器"><a href="#2-4-1启动类加载器" class="headerlink" title="2.4.1启动类加载器"></a>2.4.1启动类加载器</h3><p><img src="../images/jvm/jvm-2-%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg"></p><h3 id="2-4-2扩展类加载器"><a href="#2-4-2扩展类加载器" class="headerlink" title="2.4.2扩展类加载器"></a>2.4.2扩展类加载器</h3><p><img src="../images/jvm/jvm-2-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg"></p><h3 id="2-4-3应用程序类加载器"><a href="#2-4-3应用程序类加载器" class="headerlink" title="2.4.3应用程序类加载器"></a>2.4.3应用程序类加载器</h3><p><img src="../images/jvm/jvm-2-%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg"></p><h3 id="2-4-4自定义类加载器"><a href="#2-4-4自定义类加载器" class="headerlink" title="2.4.4自定义类加载器"></a>2.4.4自定义类加载器</h3><p>我们平时开发中，类加载几乎都是上面3种类加载器配合使用的，那我们为什么还需要使用自定义类加载器呢？</p><ul><li>防止加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul><p>问：关于如何编写自定义类加载器呢？</p><p>答：我们可以直接继承URLClassLoader类</p><p>【注：本教程旨在互相学习，有借鉴搬移其他平台（比如尚硅谷）的成分，不为盈利（bilbil尚硅谷确实很好）】</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在idea中以Typora打开.md文件的方法</title>
      <link href="/posts/2e40f549.html"/>
      <url>/posts/2e40f549.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在写博客的时候使用idea自带的.md书写模式感觉好怪，所以我寻找了一下如何在idea中以Typora打开以.md结尾的文件。</p></blockquote><p><img src="https://markdown-1258124344.cos.ap-guangzhou.myqcloud.com/%20image/image-20220117192840798.png"></p><p>这样idea就会以系统默认的方式打开.md文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring系列-第1篇【手写部分spring源码】</title>
      <link href="/posts/d882f8af.html"/>
      <url>/posts/d882f8af.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>moon<span class="token punctuation">.</span>spring</span><span class="token punctuation">;</span><span class="token comment">/** * @author MoonLeaves * @create 2022-04-05 13:37 * @describe:这是spring容器，作为一个容器，是用来存放创建的对象仓库 */</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">Introspector</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">File</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationTargetException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">;</span><span class="token comment">/** * ComponentScan,Component方面联系: * 作为一个仓库，他是利用component去判定哪一个是要被创建的对象，所以他必须和component有关系，即找到扫描路径 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MoonApplicationContext</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> CONSTANT_SCOPE_NAME_SINGLETON <span class="token operator">=</span> <span class="token string">"singleton"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> CONSTANT_SCOPE_NAME_PROPERTY <span class="token operator">=</span> <span class="token string">"property"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Class</span> configClass<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">&gt;</span></span> beanDefinitionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//单例池</span>    <span class="token keyword">private</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//判断出一个Component之后就判断这个clazz是否有BeanPostProcessor接口</span>    <span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanPostProcessor</span><span class="token punctuation">&gt;</span></span> beanPostProcessorList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 这个构造方法就是接受到一个配置类，然后判断是否是ComponentScan注解     * 如果有ComponentScan注解:     * 1.就根据ComponentScan的value找到要扫描的包com.moon.service【这一步运用了classLoader.getResource得到；文件在项目中的绝对路径】     * 2.然后拿到包内的所有文件，筛选出class结尾的文件     * 3.遍历：然后去所有的class文件中去遍历所有标注了Component注解的文件     * 4.有Component注解的类就是我们想要的鉴定的类     * 5.我们用一个包装bean对象( BeanDefinition )去封装原始类，     * 6.需要封装的其实就是这个类的Class属性和scope.value     * 7.遍历之后：所以要把他存起来，ConcurrentHashMap&lt;String, BeanDefinition&gt;，存放的是bean名字和bean封装对象(Class,scope)     * &lt;p&gt;     * 8.按说遍历之后就已经结束了，但是spring绝对在容器创建成功之后，直接把单例模式的bean创建一下所以     * 9.创建单例bean对象,创建bean对象用的是一个private类型的createBean()     * 10.为了创建单例对象，我们先设计一个单例池ConcurrentHashMap&lt;String, Object&gt;     * 11.每次创建成功单例bean对象，就把这个对象放到单例池中.     * 12.我们对外开启的getBean()方法就从这个池子里拿取     *     * @param configClass     */</span>    <span class="token comment">/**     * 关于依赖注入：     * &lt;p&gt;     * 前面我们完成了容器的创建，找到了bean,然后创建bean,但是我们创建还没有完成，因为没有解决依赖注入的方法。     * 依赖注入就是要求在创建bean对象之后就把值给赋了，所以     * 在Object instance = clazz.getConstructor().newInstance();执行之后就先要遍历他的属性，然后看看是否有Autowired注解，如果有     * 就证明这个属性也是通过spring去创建的，所以我们调用 f.set(instance, getBean(f.getName()));去创建对象。【注意这里有个A.B问题】     * &lt;p&gt;     * &lt;p&gt;     * &lt;p&gt;     * 关于回调机制和初始化机制：     * &lt;p&gt;     * 因为我们借助的是两个接口（BeanNameAware，InitializingBean）去判断他是否有这个操作，在createdBean内，我们就要判断是否有这个注解，然后去操作     * &lt;p&gt;     * &lt;p&gt;     * &lt;p&gt;     * 关于AOP机制：     * &lt;p&gt;     * 我们也是需要一个接口BeanPostProcessor，在判断出他是一个component之后，就判断他是否有BeanPostProcessor接口，如果有就添加到一个池子里beanPostProcessorList，方便以后使用     * 在我们进行完回调和初始化机制之后，我们就可以执行BeanPostProcessor的前置方法了     */</span>    <span class="token keyword">public</span> <span class="token class-name">MoonApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">Class</span> configClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>configClass <span class="token operator">=</span> configClass<span class="token punctuation">;</span>        <span class="token comment">//判断是否有ComponentScan注解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>configClass<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">ComponentScan</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果有就获取到这个ComponentScan注解类对象</span>            <span class="token class-name">ComponentScan</span> <span class="token class-name">ComponentScanAnnotation</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ComponentScan</span><span class="token punctuation">)</span> configClass<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">ComponentScan</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//所以这就是ComponentScan的扫描路径，其实一个包名com.moon.service</span>            <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token class-name">ComponentScanAnnotation</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//com.moon.service---&gt;com/moon/service</span>            path <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//tips:我们根据classpath去获取真正的路径名</span>            <span class="token comment">//获取容器的类加载器</span>            <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">MoonApplicationContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//根据类加载器能得到资源</span>            <span class="token class-name">URL</span> resource <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//此时获取到的file路径就是我们想要的</span>            <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>resource<span class="token punctuation">.</span><span class="token function">getFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//D:\Study\Code\Study\Spring\SpringSourceCode\SpringSourceCode_01\target\classes\com\moon\service</span><span class="token comment">//            System.out.println(file);</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//获取到文件夹内所有的文件</span>                <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">File</span> f <span class="token operator">:</span> files<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">String</span> filename <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//获取到所有的文件名 D:\Study\Code\Study\Spring\SpringSourceCode\SpringSourceCode_01\target\classes\com\moon\service\UserService.class</span><span class="token comment">//                    System.out.println(filename);</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>filename<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">".class"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">//     com\moon\service\UserService</span>                        <span class="token class-name">String</span> className <span class="token operator">=</span> filename<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>filename<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"com"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> filename<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">".class"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//     com.moon.service.UserService</span>                        className <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"\\"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//                        System.out.println(className);</span>                        <span class="token comment">//使用类加载器，传入类的全限定名加载类</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            <span class="token comment">//使用类加载器加载类</span>                            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">//如果有Component注解,就证明这个是bean对象</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment">//判断这个类是否是实现了BeanPostProcessor接口</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">BeanPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token class-name">BeanPostProcessor</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BeanPostProcessor</span><span class="token punctuation">)</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    beanPostProcessorList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                                <span class="token class-name">Component</span> component <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//获取bean的名字</span>                                <span class="token class-name">String</span> beanName <span class="token operator">=</span> component<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//spring要求生成的bean名字首字母要小写</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    beanName <span class="token operator">=</span> <span class="token class-name">Introspector</span><span class="token punctuation">.</span><span class="token function">decapitalize</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                                <span class="token comment">//这个是包装bean类型</span>                                <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//设置包装bean类型的类</span>                                beanDefinition<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//然后判断是否这个类是否有scope注解</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Scope</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token class-name">Scope</span> scopeAnnotation <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Scope</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">//这个类的scope值</span>                                    beanDefinition<span class="token punctuation">.</span><span class="token function">setScope</span><span class="token punctuation">(</span>scopeAnnotation<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                    beanDefinition<span class="token punctuation">.</span><span class="token function">setScope</span><span class="token punctuation">(</span>CONSTANT_SCOPE_NAME_SINGLETON<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                                <span class="token comment">//向集合中中添加bean</span>                                beanDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> beanName <span class="token operator">:</span> beanDefinitionMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> beanDefinitionMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>beanDefinition<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>CONSTANT_SCOPE_NAME_SINGLETON<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//创建单例bean</span>                <span class="token class-name">Object</span> bean <span class="token operator">=</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>                singletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/**         * 1.根据beanName得到类在哪里         * 2.判断是否是单例bean         */</span>        <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> beanDefinitionMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanDefinition <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> scope <span class="token operator">=</span> beanDefinition<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//如果是单例模式</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>scope<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>CONSTANT_SCOPE_NAME_SINGLETON<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//我们从单例池中获取，单例池内的数据是在容器创建完成后就添加的</span>                <span class="token class-name">Object</span> bean <span class="token operator">=</span> singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//有一种情形，就是A.B  如果要创建A,而A引用了B，但是A先被扫描到了，B还有创建，所以就创建B</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>                    singletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> bean<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//多例模式</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">createBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">BeanDefinition</span> beanDefinition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//当前bean对应的类</span>        <span class="token class-name">Class</span> clazz <span class="token operator">=</span> beanDefinition<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//使用无参构造方法生成一个bean</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Object</span> instance <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//给一个bean依赖注入，首先要遍历一个bean的属性</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> f <span class="token operator">:</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Autowired</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//f.getName()找的就是OrderService orderService中的 orderService</span>                    <span class="token comment">//A.B 此时就先去创建B</span>                    f<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token function">getBean</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">//如果当前类实现了BeanNameAware接口</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">BeanNameAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//回调机制，直接自己干事</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">BeanNameAware</span><span class="token punctuation">)</span> instance<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanPostProcessor</span> beanPostProcessor <span class="token operator">:</span> beanPostProcessorList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                instance <span class="token operator">=</span> beanPostProcessor<span class="token punctuation">.</span><span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//初始化机制，只用于调用，但是具体做了什么事情，用户才知道，调用的是用户的方法</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">InitializingBean</span><span class="token punctuation">)</span> instance<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanPostProcessor</span> beanPostProcessor <span class="token operator">:</span> beanPostProcessorList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                instance <span class="token operator">=</span> beanPostProcessor<span class="token punctuation">.</span><span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> instance<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm系列-第1篇【jvm基本结构】</title>
      <link href="/posts/15bc6d90.html"/>
      <url>/posts/15bc6d90.html</url>
      
        <content type="html"><![CDATA[<h1 id="jvm系列-第1篇【jvm基本结构】"><a href="#jvm系列-第1篇【jvm基本结构】" class="headerlink" title="jvm系列-第1篇【jvm基本结构】"></a>jvm系列-第1篇【jvm基本结构】</h1><h2 id="1-jvm是什么？"><a href="#1-jvm是什么？" class="headerlink" title="1.jvm是什么？"></a>1.jvm是什么？</h2><p>JVM是java虚拟机（Java Virtual Machine）的英文简称。</p><p>​    虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p><blockquote><p>简单来说JVM是用来解析和运行Java程序的。</p></blockquote><p>大家都知道Java是跨平台的语言，这都要归功于java虚拟机，即jvm的作用。为了让大家更好理解jvm的跨平台性，这里贴一张图。</p><p><img src="../images/jvm/jvm-1-jvm%E8%B7%A8%E5%B9%B3%E5%8F%B0.jpg"></p><p>Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码==（字节码）==，就可以在多种平台上不加修改地运行。最终实现一次编译，到处执行。</p><p>那么jvm在那里呢？</p><p><img src="../images/jvm/jvm-1-jvm%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg"></p><p>​    用户使用编译器（javac指令）编译出字节码文件【tips:1】。然后只要你的电脑里安装了jre【tips:2】，就可以运行这个字节码文件了。</p><p>tips1:【idea这种是编辑器，他可以使用快捷的使用javac编译出字节码文件】</p><p>tips2:【我们安装的jdk（开发工具包）已经包括了jre(运行环境)】</p><p><img src="../images/jvm/jvm-1-jdk%E4%B8%8Ejre.jpg"></p><p>【JRE包括JVM,JDK包括JRE,IDEA使用JDK】</p><p>好了，我们要学习的重点只是就是os上，jre下的JVM，鼎鼎大名的==JVM虚拟机==！！</p><h2 id="2-jvm包括什么？"><a href="#2-jvm包括什么？" class="headerlink" title="2.jvm包括什么？"></a>2.jvm包括什么？</h2><p>jvm其实很复杂，这里先给大家展示一下他的简略结构图</p><p><img src="../images/jvm/jvm-1-jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E7%AE%80%E6%B4%81%E7%89%88.jpg"></p><p>看图我们知道，jvm有以下几个部分：</p><ol><li>类加载子系统</li><li>运行时数据区【方法区，堆，java栈，本地方法栈，程序计数器】</li><li>执行引擎</li><li>本地方法接口</li><li>本地方法库</li></ol><p>​    前面说过，我们是通过编译器编译出==字节码文件==，然后给jvm的，所以我们看这个图可以发现，jvm的初始入口就是从字节码文件开始的。</p><p>我们将这个图稍微细化一些。<br><img src="../images/jvm/jvm-1-jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></p><p>同学们，不要慌。我们接下来将会对这里面的结构进行拆块的剖析。</p><p>【注：本教程旨在互相学习，有借鉴搬移其他平台（比如尚硅谷）的成分，不为盈利（bilbil尚硅谷确实很好）】</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java面试系列-第1篇【java基础】</title>
      <link href="/posts/96ab36bf.html"/>
      <url>/posts/96ab36bf.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇-java基础"><a href="#第一篇-java基础" class="headerlink" title="第一篇 java基础"></a>第一篇 java基础</h1><h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a>1.<strong>面向对象和面向过程的区别</strong></h3><h4 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a><strong>面向过程：</strong></h4><p><strong>优点：</strong> 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗 </p><p>资源;比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是 </p><p>最重要的因素。 </p><p><strong>缺点：</strong> 没有面向对象易维护、易复用、易扩展</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><strong>面向对象</strong></h4><p><strong>优点：</strong> 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 </p><p><strong>缺点：</strong> 性能比面向过程低</p><h3 id="2-什么是字节码文件"><a href="#2-什么是字节码文件" class="headerlink" title="2.什么是字节码文件"></a>2.什么是字节码文件</h3><p>​    在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文 件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计算机上运行</p><h3 id="3-java面向对象编程的三大特征？"><a href="#3-java面向对象编程的三大特征？" class="headerlink" title="3.java面向对象编程的三大特征？"></a>3.java面向对象编程的三大特征？</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>概念：即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。</p><p>优点：</p><ul><li>把对象的私有数据和公共数据分离开，保护了私有数据，减少了可能的模块间干扰，达到降低程序复杂性、提高可控性的目的。</li><li>清楚的体现了系统之间的松散耦合关系,提高系统的独立性；</li><li>提高了程序的可复用性和可维护性，降低了程序员保持数据与操作内容的负担。</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>概念：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。</p><p>优点：</p><ul><li>简化代码，提高复用性；</li><li>增加可维护性；</li></ul><p><em>继承注意事项：</em></p><ol><li>子类不继承其父类的构造方法。<ul><li>当使用无参数的super()时，父类的无参数构造方法就会被调用；</li><li>当使用带有参数的super()方法时，父类的有参数构造方法就会被调用。</li></ul></li><li>子类继承其父类的所有public和protected成员，但不能继承其父类的private成员。</li><li>重写父类中的方法：当一个子类中一个实例方法具有与其父类中的一个实例方法相同的签名（指名称、参数个数和类型）和返回值时，称子类中的方法“重写”了父类的方法。调用重写方法时，调用的为子类重写的方法。</li><li>隐藏父类中的方法：如果一个子类定义了一个<strong>静态类方法</strong>，而这个类方法与其父类的一个类方法具有相同的签名（指名称、参数格式和类型）和返回值，则称在子类中的这个类方法“隐藏”了父类中的该类方法。调用隐藏方法时，取决于对象是父类对象的调用还是子类对象的调用</li><li>可以在子类中通过使用关键字super()来调用父类中被重写的方法和访问父类中被隐藏的字段。</li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>概念：统一行为具有多个不同表现形式或形态能力</p><p>优点：</p><ol><li>消除类型之间的耦合关系</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li><li>可替换性</li></ol><p>多态的实现方式：</p><p>方式1：重载和重写</p><p>重载：在一个类中，同一方法名称，不同的参数及个数，可以完成不同的功能</p><p>重写：同一个方法名称，子类继承父类的方法，根据操作的子类不同，所完成的功能也不同。</p><p>方式2：抽象类和抽象方法</p><p>抽象方法:一个没有方法体的方法称为抽象方法。abstract</p><p>特点:</p><ol><li>抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类</li><li>抽象类不可以是实例化</li><li>抽象类的子类，可以是抽象类，也可以是具体类。如果子类为具体类，需要重写抽象类中所有抽象方法</li></ol><p>方式3：接口</p><p>定义:是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。</p><p>接口无法被实例化，但是可以被实现.一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</p><h3 id="4-hashCode-与equals"><a href="#4-hashCode-与equals" class="headerlink" title="4.hashCode 与equals"></a>4.hashCode 与equals</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals 时必须重写 hashCode 方法？</p><h4 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h4><p>​    hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整 数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函 数</p><p>​    散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a><strong>为什么要有</strong> hashCode</h4><p>我们以”HashSet如何检查重复”为例子来说明为什么要有hashCode：</p><p>​    当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度</p><h4 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h4><ol><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol>]]></content>
      
      
      <categories>
          
          <category> java面试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
